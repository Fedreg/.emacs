d#+TITLE: Fed's Emacs Configuration (evil centric)

This file is loaded by =init.el=, using babel.

* General

Settings that are generally applicable in all situations

** Enable Debugging

In case anything goes wrong during startup, it is very useful to have debugging on

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
(setq debug-on-quit t)
#+END_SRC

** UTF-8

Always use UTF-8 when possible

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
#+END_SRC

** Setup packages

#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC

Remove HTTP entries from package archives

#+BEGIN_SRC emacs-lisp
(setq package-archives nil)
#+END_SRC

Add package repositories (GNU, melpa[-stable], marmalade, and org-elpa)

#+BEGIN_SRC emacs-lisp
(defvar gnu '("gnu" . "https://elpa.gnu.org/packages/"))
(defvar melpa '("melpa" . "https://melpa.org/packages/"))
(defvar melpa-stable '("melpa-stable" . "https://stable.melpa.org/packages/"))
(defvar marmalade '("marmalade" . "https://marmalade-repo.org/packages/"))
(defvar org-elpa '("org" . "http://orgmode.org/elpa/"))

(add-to-list 'package-archives gnu t)
(add-to-list 'package-archives melpa t)
(add-to-list 'package-archives melpa-stable t)
(add-to-list 'package-archives marmalade t)
(add-to-list 'package-archives org-elpa t)
#+END_SRC

Evaluate package list

#+BEGIN_SRC emacs-lisp
(defun packages-install (&rest packages)
  (mapc (lambda (package)
          (let ((name (car package))
                (repo (cdr package)))
            (when (not (package-installed-p name))
              (let ((package-archives (list repo)))
                (package-initialize)
                (package-install name)))))
        packages)
  (package-initialize)
  (delete-other-windows))
#+END_SRC

Install missing packages

#+BEGIN_SRC emacs-lisp
(defun init--install-packages ()
  (packages-install
   (cons 'use-package melpa)))

(condition-case nil
    (init--install-packages)
  (error
   (package-refresh-contents)
   (init--install-packages)))
#+END_SRC

** Startup

Don't show the startup message

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC

Set the initial mode to Fundamental

#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'fundamental-mode)
#+END_SRC

Fullscreen window

#+BEGIN_SRC emacs-lisp
(add-hook 'window-setup-hook 'toggle-frame-fullscreen nil)
#+END_SRC

** Echo commands

Only wait .3 seconds to show unfinished keystrokes (default 1 second)

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes .3)
#+END_SRC

** GUI

Hide the toolbar, menubar, scrollbar, and tooltips

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode 1)
(scroll-bar-mode -1)
(tooltip-mode 1)


#+END_SRC

Show lines and columns in the mode line

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Show line numbers on the margin

#+BEGIN_SRC emacs-lisp
;(global-linum-mode)
#+END_SRC

Hide the mouse when typing

#+BEGIN_SRC emacs-lisp
;(setq make-pointer-invisible t)
#+END_SRC

Use a solid cursor (no blinking)

#+BEGIN_SRC emacs-lisp
;(blink-cursor-mode -1)
#+END_SRC

Stop =C-z= from suspending the frame

Note that it is reset to =undo-tree-undo= below

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-z"))
#+END_SRC

** =$PATH=

Load the correct path when on unix-y systems

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t)

(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+END_SRC

** Syntax Highlighting

Always highlight syntax

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

** Files/Buffers

Save state between sessions. You may also want to look at the
functionality =bookmark+= has for saving desktops.

#+BEGIN_SRC emacs-lisp
;(desktop-save-mode 1)
#+END_SRC

Change custom file (so =init.el= isn't modified)

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Resolve symlinks

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename t)
#+END_SRC

Require newline

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Don't create lockfiles

#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

Fix duplicate buffers by adding the directory when necessary

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

Save the cursor location in files between sessions

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :defer t
  :init
    (setq-default save-place t)
    (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC

Never kill =*scratch*= (just bury it)

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

Sets the save history file

#+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables
      ;; save search entries as well
      '(search-ring regexp-search-ring)
      savehist-file (expand-file-name "savehist" user-emacs-directory))
(savehist-mode t)
(setq-default save-place t)
#+END_SRC

Use custom backup directory, move deleted files to trash

#+BEGIN_SRC emacs-lisp
(defvar --backup-directory (concat init-dir "backups"))

(if (not (file-exists-p --backup-directory))
    (make-directory --backup-directory t))

(setq backup-directory-alist `(("." . ,--backup-directory)))
(setq make-backup-files         t    ;; backup on first save
      backup-by-copying         t    ;; don't use symlinks
      version-control           t    ;; add version numbers
      delete-old-versions       t    ;; delete extra backups silently
      delete-by-moving-to-trash t    ;; move to trash
      kept-old-versions         6    ;; oldest version to keep when a new backup is made
      kept-new-versions         9    ;; newest version to keep when a new backup is made
      auto-save-default         t    ;; autosave each buffer that visits a file
      auto-save-timeout         29   ;; 20 seconds of idle time before autosaving
      auto-save-interval        200) ;; 200 keystrokes before autosaving
#+END_SRC

** Clipboard

Save clipboard from other program into kill ring before replacing it

#+BEGIN_SRC emacs-lips
(setq save-interprogram-paste-before-kill t)
#+END_SRC

** Sounds

Disable bells

#+BEGIN_SRC emacs-lisp
(defun nothing-bell-function ())

(setq ring-bell-function 'nothing-bell-function)
(setq visible-bell nil)
#+END_SRC

** Spelling

Enable Aspell, with fast settings, at least 3 chars

#+BEGIN_SRC emacs-lisp
(defun spell-buffer-english ()
  (interactive)
  (ispell-change-dictionary "en_US")
  (flyspell-buffer))

(use-package ispell
  :config
  (when (executable-find "aspell")
    (setq-default ispell-program-name "aspell"
                  ispell-extra-args '("--sug-mode=ultra"
                                      "--lang=en_US"
                                      "--ignore=3")))
  :bind (("C-c n" . spell-buffer-english)))
#+END_SRC

** Auto Save

Auto Save buffers
#+BEGIN_SRC emacs-lisp
(use-package super-save
  :ensure t
  :config
  (super-save-mode +1))
#+END_SRC

* Look & Feel
** Tree

#+BEGIN_SRC emacs-lisp
(use-package dired-sidebar
  :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
  :ensure t
  :commands (dired-sidebar-toggle-sidebar)
  :config
  (use-package all-the-icons-dired
    ;; M-x all-the-icons-install-fonts
    :ensure t
    :commands (all-the-icons-dired-mode)))
#+END_SRC

** Font

#+BEGIN_SRC emacs-lisp
(defun uplift/osx-fonts ()
  (interactive)
  (set-fontset-font "fontset-default" 'symbol "Menlo")
  (setq mac-allow-anti-aliasing t))

(defun uplift/linux-fonts ()
  (interactive)
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono")))

(when (eq system-type 'darwin)
  (add-hook 'after-init-hook #'uplift/osx-fonts))

(when (eq window-system 'x)
  (add-hook 'after-init-hook #'uplift/linux-fonts))

(setq-default line-spacing 5)

; (when (window-system)
;  (set-frame-font "Menlo"))
; (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
;                  (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
;                  (36 . ".\\(?:>\\)")
;                  (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
;                  (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
;                  (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
;                  (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
;                  (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
;                  ;; (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
;                  (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
;                  (48 . ".\\(?:x[a-zA-Z]\\)")
;                  (58 . ".\\(?:::\\|[:=]\\)")
;                  (59 . ".\\(?:;;\\|;\\)")
;                  (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
;                  (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
;                  (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
;                  (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
;                  (91 . ".\\(?:]\\)")
;                  (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
;                  (94 . ".\\(?:=\\)")
;                  (119 . ".\\(?:ww\\)")
;                  (123 . ".\\(?:-\\)")
;                  (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
;                  (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
;                  )
;                ))
;     (dolist (char-regexp alist)
;       (set-char-table-range composition-function-table (car char-regexp)
;                             `([,(cdr char-regexp) 0 font-shape-gstring]))))

#+END_SRC

** Theme

Use the doom themes

#+BEGIN_SRC emacs-lisp
(use-package clues-theme
  :ensure t
  :config (load-theme 'clues t))
#+END_SRC
** Modeline

Use doom modeline

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
      :ensure t
      :defer t
      :hook (after-init . doom-modeline-init))
#+END_SRC

* Navigation

** Prompts

Ask for y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Undo tree

The default Emacs undo system is fairly confusing at first, this changes it to an alternative

It also provides a way to visualize it (use C-x u)

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :defer t
  :init (global-undo-tree-mode t)
  :bind
    (("C-x u" . undo-tree-visualize)
     ("C-/" . undo-tree-undo)
     ("C-z" . undo-tree-undo)))
#+END_SRC

** Projectile Everywhere

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'projectile-global-mode)
#+END_SRC

** Counsel

Counsel ensures that you use the Ivy versions of common commands, which offer great completion

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :bind
  (("M-x" . counsel-M-x)
   ("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))

(use-package counsel-projectile
  :ensure t
  :config (counsel-projectile-mode))

(use-package flx
  :ensure t)
#+END_SRC

Use regex plus mode for ivy searching

#+BEGIN_SRC emacs-lisp
(setq ivy-re-builders-alist
      '((t . ivy--regex-plus)))
#+END_SRC

** Buffers

When =C-k= is used, don't prompt for a buffer to kill. Just kill the current one.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

Use ibuffer instead of buffer-menu

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

** Mouse scrolling

The default mouse scrolling is very choppy. This makes it smoother, and stops it from speeding up with the mouse wheel.

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
(setq mouse-wheel-progressive-speed nil)
#+END_SRC

** Evil Mode

Evil mode is Emacs version of VIM modal editing.

#+BEGIN_SRC emacs-lisp
(use-package evil
 :ensure t
 :config (evil-mode 1))

(use-package evil-escape
 :ensure t
 :config (evil-escape-mode 1))
(setq-default evil-escape-key-sequence "jk")

#+END_SRC

** which-key

Shows possible keybinding completions

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config (which-key-mode))
#+END_SRC

** Swiper

Search integrated with counsel and ivy

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :pin melpa-stable
  :diminish ivy-mode
  :ensure t
  :bind*
  (("C-s" . swiper)
   ("C-c C-r" . ivy-resume)
   ("C-x C-f" . counsel-find-file)
   ("C-c h f" . counsel-describe-function)
   ("C-c h v" . counsel-describe-variable)
   ("C-c i u" . counsel-unicode-char)
   ("M-i" . counsel-imenu)
   ("C-c g" . counsel-git)
   ("C-c j" . counsel-git-grep)
   ("C-c k" . counsel-ag)
   ("C-c l" . scounsel-locate))
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (define-key read-expression-map (kbd "C-r") #'counsel-expression-history)
    (ivy-set-actions
     'counsel-find-file
     '(("d" (lambda (x) (delete-file (expand-file-name x)))
        "delete")))
    (ivy-set-actions
     'ivy-switch-buffer
     '(("k"
        (lambda (x)
          (kill-buffer x)
          (ivy--reset-state ivy-last))
        "kill")
       ("j"
        ivy--switch-buffer-other-window-action
        "other window")))))
#+END_SRC

** Ace-Window

Ask which window to switch to by placing numbers in each. It can be weird at first, but speeds things up in the end.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :bind (("C-x o" . ace-window)
         ("C-c o" . other-window)))

(use-package ace-jump-mode
  :ensure t
  :bind (("C-c C-SPC" . ace-jump-mode)))
#+END_SRC

* Programming
** General
*** Version Control

Add support for git with magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-c m" . magit-status)))

(use-package magit-gitflow
  :ensure t
  :config (add-hook 'magic-mode-hook 'turn-on-magit-gitflow))
#+END_SRC

*** Auto Completion

Install company and use it everywhere

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :bind (("TAB" . company-indent-or-complete-common))
  :config (global-company-mode))
#+END_SRC

Add fuzzy matching to company

#+BEGIN_SRC emacs-lisp
(use-package company-flx
  :ensure t)
#+END_SRC

Add quickhelp to show documentation

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  :config (company-quickhelp-mode 1))

(use-package pos-tip
  :ensure t)
#+END_SRC

*** Highlighting

Highlight matching parentheses

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC

Show trailing whitespace

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
#+END_SRC

*** Spaces

Use spaces instead of tabs, always

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

*** Better Defaults

Better Defaults without the fuss

#+BEGIN_SRC emacs-lisp
(use-package better-defaults
  :ensure t)
#+END_SRC

*** Code Folding

Activate by mode
#+BEGIN_SRC emacs-lisp
(add-hook 'clojure-mode-hook 'hs-minor-mode)
#+END_SRC

** General Lisps

Highlight parentheses

#+BEGIN_SRC emacs-lisp
(use-package highlight-parentheses
  :ensure t
  :diminish highlight-parentheses-mode
  :config (add-hook 'prog-mode-hook #'highlight-parentheses-mode))
#+END_SRC

Enable rainbow delimiters

# #+BEGIN_SRC emacs-lisp
# (use-package rainbow-delimiters
#   :ensure t
#   :config (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
# #+END_SRC

** Common Lisp

#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t)
  (setq inferior-lisp-program "/usr/local/bin/sbcl")
  (add-hook 'lisp-mode-hook (lambda () (slime-mode t)))
  (add-hook 'inferior-lisp-mode-hook (lambda () (inferior-slime-mode t)))

  (add-hook 'slime-repl-mode-hook
          (lambda ()
            (el-get 'sync 'slime-repl-ansi-color)
            (slime-setup '(slime-fancy slime-banner slime-indentation slime-repl-ansi-color))))

  (slime-setup '(slime-fancy slime-asdf))

#+END_SRC

** Clojure

=clojure-mode= offers some nice features (e.g. =clojure-fill-docstring=)

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :bind (("C-c M-q" . lisp-fill-paragraph)
           ("C-x 9" . display-line-numbers-mode)))
#+END_SRC

CIDER does all of the heavy lifting for Clojure

#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t
  :pin melpa-stable
   :config
     (setq cider-repl-use-pretty-printing       t)
     (setq cider-repl-display-help-banner       nil)
     (setq cider-auto-jump-to-error             nil)
     (setq cider-auto-select-error-buffer       nil)
     (setq cider-show-error-buffer              :only-in-repl)
     (setq cider-auto-select-test-report-buffer nil)
     (setq cider-repl-history-file              (expand-file-name "cider-history" user-emacs-directory))
   :bind (:map cider-repl-mode-map
              ("M-r" . cider-namespace-refresh)
              ("C-c DEL" . cider-repl-clear-buffer)))
#+END_SRC

More clojure highlighting

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode-extra-font-locking
  :ensure t)
#+END_SRC

Add clojure snippets to yasnippet

#+BEGIN_SRC emacs-lisp
(use-package clojure-snippets
  :ensure t)
#+END_SRC

Refactor support for Clojure

#+BEGIN_SRC emacs-lisp
(require 'clj-refactor)

(defun my-clojure-mode-hook ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1) ; for adding require/use/import statements
    (cljr-add-keybindings-with-prefix "C-c C-m"))

(add-hook 'clojure-mode-hook #'my-clojure-mode-hook)
#+END_SRC
** Elixir

Alchemist is the Elixir mode for Emacs
#+BEGIN_SRC emacs-lisp
(use-package alchemist
  :ensure t)
#+END_SRC

** Elm

Elm Mode
#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :ensure t)
#+END_SRC

Elm Format on Save
#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :ensure t)
#+END_SRC
** Go-lang

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t)
#+END_SRC

Local Go playground in emacs
#+BEGIN_SRC emacs-lisp
(use-package go-playground
  :ensure t)
#+END_SRC

Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :pin melpa-stable
  :init (global-flycheck-mode))
#+END_SRC

Gofmt & flycheck on save
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

** Java
#+BEGIN_SRC emacs-lisp
(require 'cc-mode)

(use-package projectile :ensure t)
(use-package treemacs :ensure t)
(use-package lsp-mode :ensure t)
(use-package hydra :ensure t)
(use-package company-lsp :ensure t)
(use-package lsp-ui :ensure t)
(use-package lsp-java
  :ensure t
  :after lsp
  :config
  (setq lsp-java-save-action-organize-imports nil)
  (add-hook 'java-mode-hook 'lsp))

(use-package dap-mode
  :ensure t :after lsp-mode
  :config
  (dap-mode t)
  (dap-ui-mode t))

(use-package dap-java :after (lsp-java))
(use-package lsp-java-treemacs :after (treemacs))
#+END_SRC

Not Java specific but I've only had this issue when working with Java so...
#+BEGIN_SRC emacs-lisp
(defun remove-dos-eol ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M []))
#+END_SRC
** Markdown

Use markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC

** Org

Highlight code in =#+BEGIN_SRC ... #+END_SRC= blocks in org files

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Add the time when a TODO item is marked completed

#+BEGIN_SRC emacs-lisp
(setq org-log-done t)
#+END_SRC

Markdown Export
#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :ensure t)
#+END_SRC

** Web

web-mode is good for editing HTML and JS

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.xhtml?\\'" . web-mode))

  (defun uplift/web-mode-hook ()
    "Hooks for Web mode"
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-quoting t)
    (setq web-mode-markup-indent-offset 2))

  (add-hook 'web-mode-hook 'uplift/web-mode-hook))

(use-package less-css-mode
  :ensure t)

(use-package emmet-mode
  :ensure t
  :config (add-hook 'web-mode-hook 'emmet-mode))
#+END_SRC

* Keymaps


Switch back to last buffer
#+BEGIN_SRC emacs-lisp
(defun switch-to-previous-buffer ()
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(global-set-key (kbd "C-c b") 'switch-to-previous-buffer)
#+END_SRC

Run Cider Debugger
#+BEGIN_SRC emacs-lisp
(defun my-cider-debug-setup ()
  (evil-make-overriding-map cider--debug-mode-map 'normal)
  (evil-normalize-keymaps))

(add-hook 'cider--debug-mode-hook 'my-cider-debug-setup)

(defun run-cider-debugger()
  (interactive)
  (cider-debug-defun-at-point))

(global-set-key (kbd "C-c d") 'run-cider-debugger)

(global-auto-revert-mode t)
#+END_SRC

Jump to definition
#+BEGIN_SRC emacs-lisp
(defun jump-to-variable-definition ()
  (interactive)
  (cider-find-var))

(global-set-key (kbd "C-c v") 'jump-to-variable-definition)
#+END_SRC

* Finalize
** Rest Client
A http client for a postman like experience from within emacs!

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t
  :mode ("\\.http\\'" . restclient-mode))
#+END_SRC

** Disable debugging

Startup finished, turn debugging off

#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
(setq debug-on-quit nil)
#+END_SRC

